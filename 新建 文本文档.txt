发送端
首先判断seq是否在窗口范围内，因为是运用到一些取模之类的就有点复杂，就不赘述，然后使用fread读入，然后再设置一下数据报，包括设置一下checksum，再给它给保存。
然后就到发送buf内的数据并且记录发送的时间，同时有一定的输出日志，打印剩余的可用窗口以及发送详情。

然后到了超时重传的部分，每发完一个包就检测一下窗口内是否有超时了需要重传的数据包。具体为判断该号数据包没收到接收端发送过来的ack而且clock的时间差大于设置的超时范围。
关于超时判断，在for循环中每个包都有一个计时器记录发送的时间（issend），将它与当前时间进行做差就能够判断是否超时，如果这个包超时了就重传这个包

同时因为设置了非阻塞，，就可以在这里进行ack的接收，如果在窗口范围内并且ack对应的是刚发送的包的ack，就进行窗口滑动，即给base_seq更新一下；如果不在窗口内或者是其他数据就进行丢弃




接收端
接收端主要就是这个关于窗口滑动的部分，前面就是绑定连接挥手这些过程
首先是判断到接收到文件数据，先把这个包缓存到buff，然后获取一下数据的长度，数据报的序列号和下一个序列号并且计算校验和。如果校验和没问题就回复一个ack给发送端。
然后就是判断这个包是否在窗口内，再从基序号这里遍历tureData，它记录的是每个包对应的数据的长度，如果它为零就说明这个包还没有接收到，或者是丢包了。然后它就从窗口左沿开始进行遍历，将正确的包用fwrite写入，再更新一下要滑动的长度